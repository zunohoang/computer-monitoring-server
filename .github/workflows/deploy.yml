name: CI/CD Pipeline - Deploy to VPS

# Trigger workflow khi push l√™n branch main
on:
  push:
    branches:
      - main
  workflow_dispatch: # Cho ph√©p ch·∫°y manual t·ª´ GitHub UI

env:
  DOCKER_IMAGE: ${{ secrets.DOCKER_USERNAME }}/computer-monitoring-api
  DOCKER_TAG: ${{ github.sha }}

jobs:
  # ====================================
  # Job 1: Build v√† Test
  # ====================================
  build-and-test:
    name: Build and Test
    runs-on: ubuntu-latest

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üîß Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: "8.0.x"

      - name: üì¶ Restore dependencies
        run: dotnet restore ComputerMonitoringServerAPI/ComputerMonitoringServerAPI.csproj

      - name: üèóÔ∏è Build project
        run: dotnet build ComputerMonitoringServerAPI/ComputerMonitoringServerAPI.csproj --configuration Release --no-restore

      # Optional: Uncomment n·∫øu b·∫°n c√≥ unit tests
      # - name: üß™ Run tests
      #   run: dotnet test --no-build --verbosity normal

  # ====================================
  # Job 2: Build v√† Push Docker Image
  # ====================================
  build-and-push-docker:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: build-and-test

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üîê Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: üè∑Ô∏è Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_IMAGE }}
          tags: |
            type=sha,prefix={{branch}}-
            type=raw,value=latest

      - name: üê≥ Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: |
            ${{ env.DOCKER_IMAGE }}:${{ env.DOCKER_TAG }}
            ${{ env.DOCKER_IMAGE }}:latest
          labels: ${{ steps.meta.outputs.labels }}

  # ====================================
  # Job 3: Deploy l√™n VPS
  # ====================================
  deploy-to-vps:
    name: Deploy to VPS
    runs-on: ubuntu-latest
    needs: build-and-push-docker

    steps:
      - name: üì• Checkout code (ƒë·ªÉ l·∫•y docker-compose.yml)
        uses: actions/checkout@v4

      - name: üöÄ Deploy to VPS via SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_IP }}
          username: ${{ secrets.VPS_USER }}
          password: ${{ secrets.VPS_PASSWORD }}
          port: ${{ secrets.VPS_PORT || 22 }}
          script_stop: false
          script: |
            set -x

            echo "==================================="
            echo "üöÄ Starting Deployment"
            echo "==================================="

            # Check Docker
            echo "üì¶ Checking Docker..."
            docker --version || exit 1
            docker compose version || exit 1

            # Create directory
            echo "üìÅ Creating directory..."
            mkdir -p ~/computer-monitoring-api
            cd ~/computer-monitoring-api

            # Create docker-compose.yml (KH√îNG C·∫¶N CLONE CODE)
            echo "üìù Creating docker-compose.yml..."
            cat > docker-compose.yml << 'COMPOSE_EOF'
            version: '3.8'

            services:
              postgres:
                image: postgres:16-alpine
                container_name: computer_monitoring_postgres
                restart: unless-stopped
                environment:
                  POSTGRES_DB: ${POSTGRES_DB:-ComputerMonitoring}
                  POSTGRES_USER: ${POSTGRES_USER:-postgres}
                  POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-postgres}
                ports:
                  - "5432:5432"
                volumes:
                  - postgres_data:/var/lib/postgresql/data
                networks:
                  - app-network
                healthcheck:
                  test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-postgres}"]
                  interval: 10s
                  timeout: 5s
                  retries: 5

              api:
                image: ${DOCKER_USERNAME}/computer-monitoring-api:${IMAGE_TAG:-latest}
                container_name: computer_monitoring_api
                restart: unless-stopped
                depends_on:
                  postgres:
                    condition: service_healthy
                environment:
                  - ASPNETCORE_ENVIRONMENT=${ASPNETCORE_ENVIRONMENT:-Production}
                  - ASPNETCORE_URLS=http://+:8080
                  - ConnectionStrings__DefaultConnection=Host=postgres;Database=${POSTGRES_DB:-ComputerMonitoring};Username=${POSTGRES_USER:-postgres};Password=${POSTGRES_PASSWORD:-postgres}
                  - Jwt__SecretKey=${JWT_SECRET_KEY}
                  - Jwt__Issuer=${JWT_ISSUER:-ComputerMonitoringAPI}
                  - Jwt__Audience=${JWT_AUDIENCE:-ComputerMonitoringClients}
                  - Jwt__ExpiryMinutes=${JWT_EXPIRY_MINUTES:-60}
                ports:
                  - "5000:8080"
                networks:
                  - app-network
                healthcheck:
                  test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
                  interval: 30s
                  timeout: 10s
                  retries: 3
                  start_period: 40s
                command: >
                  sh -c "
                    echo 'Waiting for database...' &&
                    sleep 10 &&
                    echo 'Running migrations...' &&
                    dotnet ef database update --no-build --verbose &&
                    echo 'Starting application...' &&
                    dotnet ComputerMonitoringServerAPI.dll
                  "

            volumes:
              postgres_data:
                driver: local

            networks:
              app-network:
                driver: bridge
            COMPOSE_EOF

            echo "‚úÖ docker-compose.yml created"

            # Create .env file
            echo "üìù Creating .env file..."
            cat > .env << 'ENV_EOF'
            DOCKER_USERNAME=${{ secrets.DOCKER_USERNAME }}
            IMAGE_TAG=latest
            POSTGRES_DB=ComputerMonitoring
            POSTGRES_USER=${{ secrets.POSTGRES_USER }}
            POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
            ASPNETCORE_ENVIRONMENT=Production
            JWT_SECRET_KEY=${{ secrets.JWT_SECRET_KEY }}
            JWT_ISSUER=ComputerMonitoringAPI
            JWT_AUDIENCE=ComputerMonitoringClients
            JWT_EXPIRY_MINUTES=60
            ENV_EOF

            echo "‚úÖ .env file created ($(wc -c < .env) bytes)"

            # Pull Docker image
            echo "üê≥ Pulling Docker image..."
            docker pull ${{ env.DOCKER_IMAGE }}:latest || exit 1
            echo "‚úÖ Image pulled"

            # Stop old containers
            echo "üõë Stopping old containers..."
            docker compose down 2>/dev/null || echo "No containers to stop"

            # Start new containers
            echo "üöÄ Starting containers..."
            docker compose up -d || exit 1
            echo "‚úÖ Containers started"

            # Wait for initialization
            echo "‚è≥ Waiting 10s for initialization..."
            sleep 10

            # Cleanup old images
            echo "üßπ Cleaning up..."
            docker image prune -af --filter "until=24h" 2>/dev/null || echo "No images to clean"

            # Show status
            echo ""
            echo "==================================="
            echo "üìä Container Status:"
            echo "==================================="
            docker compose ps

            echo ""
            echo "==================================="
            echo "üìã Recent Logs:"
            echo "==================================="
            docker compose logs --tail=30

            # Verify
            echo ""
            echo "==================================="
            echo "‚úÖ Deployment Verification:"
            echo "==================================="

            API_COUNT=$(docker compose ps api 2>/dev/null | grep -c "Up" || echo "0")
            DB_COUNT=$(docker compose ps postgres 2>/dev/null | grep -c "Up" || echo "0")

            echo "API Status: $API_COUNT"
            echo "DB Status: $DB_COUNT"

            if [ "$API_COUNT" -gt "0" ]; then
              echo "‚úÖ API is running"
            else
              echo "‚ùå API is NOT running"
            fi

            if [ "$DB_COUNT" -gt "0" ]; then
              echo "‚úÖ PostgreSQL is running"
            else
              echo "‚ùå PostgreSQL is NOT running"
            fi

            echo ""
            echo "==================================="
            echo "üéâ Deployment Complete!"
            echo "API: http://${{ secrets.VPS_IP }}:5000"
            echo "==================================="

      - name: ‚úÖ Verify deployment
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_IP }}
          username: ${{ secrets.VPS_USER }}
          password: ${{ secrets.VPS_PASSWORD }}
          port: ${{ secrets.VPS_PORT || 22 }}
          script: |
            cd ~/computer-monitoring-api

            # Ch·ªù container kh·ªüi ƒë·ªông (t·ªëi ƒëa 60 gi√¢y)
            echo "Waiting for containers to be healthy..."
            for i in {1..12}; do
              if docker compose ps | grep -q "healthy\|Up"; then
                echo "‚úÖ Containers are running!"
                docker compose ps
                exit 0
              fi
              echo "Waiting... ($i/12)"
              sleep 5
            done

            echo "‚ö†Ô∏è Warning: Containers might not be fully healthy yet"
            docker compose ps
            docker compose logs --tail=100

  # ====================================
  # Job 4: Notification (Optional)
  # ====================================
  notify:
    name: Send Notification
    runs-on: ubuntu-latest
    needs: deploy-to-vps
    if: always()

    steps:
      - name: üì¢ Notify deployment status
        run: |
          if [ "${{ needs.deploy-to-vps.result }}" == "success" ]; then
            echo "‚úÖ Deployment successful!"
            echo "üöÄ Application deployed to VPS: ${{ secrets.VPS_IP }}"
            echo "üê≥ Docker image: ${{ env.DOCKER_IMAGE }}:${{ env.DOCKER_TAG }}"
          else
            echo "‚ùå Deployment failed!"
            echo "Please check the logs above for more details."
            exit 1
          fi
